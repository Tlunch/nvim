{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Setup Python Logging": {
		"scope": "python",
		"prefix": "log",
		"body": [
			"import os",
			"import logging",
			"",
			"''' - setting up logging - '''",
			"abs_path = os.path.dirname(os.path.abspath(__file__))",
			"filename = os.path.basename(__file__)",
			"",
			"if __name__ == '__main__':",
			"    log_level = logging.INFO",
			"    log_folder = os.path.join(abs_path, 'logs')",
			"    log_file = os.path.join(log_folder, filename.replace('.py', '.log'))",
			"    log_format = '{asctime} | {filename:25} | {funcName:25} | {levelname:8} | {message}'",
			"",
			"    if not os.path.exists(log_folder):",
			"        os.mkdir(log_folder)",
			"",
			"    logging.basicConfig(level=log_level, filename=log_file, format=log_format, style='{', force=True)",
			"    logging.warning(f'---- {filename} run as main ----')",
			"",
			"else:",
			"    logging.getLogger(__name__).addHandler(logging.NullHandler())",
			"    logging.debug(f'---- {filename} imported ----')",
			""
		],
		"description": "Setup python logging for a script that is also inportable and will not overwrite the root logger. The log file will be saved in a logs folder in the same directory as the script."
	},
	"Setup Python Stdout Logging": {
		"scope": "python",
		"prefix": "log_stdout",
		"body": [
			"import os",
			"import sys",
			"import logging",
			"",
			"''' - setting up logging - '''",
			"abs_path = os.path.dirname(os.path.abspath(__file__))",
			"filename = os.path.basename(__file__)",
			"",
			"if __name__ == '__main__':",
			"    log_level = logging.INFO",
			"    log_format = '{asctime} | {filename:25} | {funcName:25} | {levelname:8} | {message}'",
			"",
			"    stdout_handler = logging.StreamHandler(sys.stdout)",
			"    stdout_handler.setLevel(log_level)",
			"    stdout_handler.setFormatter(logging.Formatter(log_format, style='{'))",
			"",
			"    logging.basicConfig(level=log_level, handlers=[stdout_handler], force=True)",
			"    logging.warning(f'---- {filename} run as main ----')",
			"",
			"else:",
			"    logging.getLogger(__name__).addHandler(logging.NullHandler())",
			"    logging.debug(f'---- {filename} imported ----')",
			""
		],
		"description": "Setup python logging for a script that is also importable and will not overwrite the root logger. The log will be printed to stdout if the script is run as the main script."
	},
	"Setup Python Stderr Logging": {
		"scope": "python",
		"prefix": "log_stderr",
		"body": [
			"import os",
			"import sys",
			"import logging",
			"",
			"''' - setting up logging - '''",
			"abs_path = os.path.dirname(os.path.abspath(__file__))",
			"filename = os.path.basename(__file__)",
			"",
			"if __name__ == '__main__':",
			"    log_level = logging.INFO",
			"    log_format = '{asctime} | {filename:25} | {funcName:25} | {levelname:8} | {message}'",
			"",
			"    stdout_handler = logging.StreamHandler(sys.stderr)",
			"    stdout_handler.setLevel(log_level)",
			"    stdout_handler.setFormatter(logging.Formatter(log_format, style='{'))",
			"",
			"    logging.basicConfig(level=log_level, handlers=[stdout_handler], force=True)",
			"    logging.warning(f'---- {filename} run as main ----')",
			"",
			"else:",
			"    logging.getLogger(__name__).addHandler(logging.NullHandler())",
			"    logging.debug(f'---- {filename} imported ----')",
			""
		],
		"description": "Setup python logging for a script that is also importable and will not overwrite the root logger. The log will be printed to stdout if the script is run as the main script."
	},

	"Setup Lambda Handler": {
		"scope": "python",
		"prefix": "def lambda_handler",
		"body": [
			"def main(event, context):",
			"    pass",
			"",
			"def lambda_handler(*args, **kwargs):",
			"    '''",
			"    Lambda Handler Function",
			"    =======================",
			"",
			"    Entry point for the AWS Lambda Runtime into the function. This function will be called by the",
			"    AWS Lambda Runtime when the function is invoked. The function will be passed the event and",
			"    context objects.",
			"",
			"    Parameters",
			"    ----------",
			"    event: dict, required",
			"        API Gateway Lambda Proxy Input Format",
			"",
			"        Event doc:",
			"        https://docs.aws.amazon.com/apigateway/latest/developerguide/set-up-lambda-proxy-integrations.html#api-gateway-simple-proxy-for-lambda-input-format",
			"",
			"    context: object, required",
			"        Lambda Context runtime methods and attributes",
			"",
			"        Context doc:",
			"        https://docs.aws.amazon.com/lambda/latest/dg/python-context-object.html",
			"",
			"    Returns",
			"    ------",
			"",
			"    Whatever lambda_handler returns will be returned to the caller of the lambda function. This is",
			"    how you do http responses in AWS Lambda.",
			"    '''",
			"",
			"    '''- setting up logging for lambda -'''",
			"",
			"    # define the log level",
			"    log_level = logging.INFO",
			"",
			"    # define the log format",
			"    log_format = (",
			"        '%(asctime)s | %(filename)s | %(funcName)s | %(levelname)s | %(message)s'",
			"    )",
			"",
			"    # define the logger",
			"    logging.basicConfig(level=log_level, format=log_format, force=True)",
			"",
			"    '''- Recording Inputs -'''",
			"    try:",
			"        logging.info('lambda_handler function called with the following inputs:')",
			"        logging.info('args:')",
			"        for arg in args:",
			"            logging.info(arg)",
			"        logging.info('kwargs:')",
			"        for key, value in kwargs.items():",
			"            logging.info(f'{key}: {value}')",
			"    except Exception as e:",
			"        logging.exception(f'Error recording inputs: {e}')",
			"",
			"    '''- Running the function -'''",
			"    try:",
			"        return main(*args, **kwargs)",
			"    except Exception as e:",
			"        logging.exception(f'Error running main function: {e}')",
			"        return {",
			"            'statusCode': 500,",
			"            'body': json.dumps(",
			"                {",
			"                    'message': 'Internal Server Error',",
			"                }",
			"            ),",
			"        }",
			"",
			"if __name__ == '__main__':",
			"    try:",
			"        main()",
			"    except Exception as e:",
			"        logging.exception(e)",
			"        raise e from e",
			""
		],
		"description": "Setup a python lambda handler function with logging."
	},
	"Create a Temp Directory Function":{
		"scope": "python",
		"prefix": "def create_temp_dir",
		"body": [
			"def create_temp_dir(folder: str) -> None:",
			"    '''",
			"    Create a temporary folder at the path provided.",
			"    ",
			"    Creates a temporary folder at the path provided if it does not exist.",
			"    If there is a temp folder already, it will be deleted iff there is a",
			"    .temp file in the folder.",
			"    ",
			"    Parameters:",
			"    folder (str): The path to the temporary folder.",
			"    ",
			"    Returns:",
			"    None",
			"    ",
			"    Raises:",
			"    FileNotFoundError: If the folder does not exist.",
			"    FileExistsError: If the temporary folder already exists.",
			"    '''",
			"    if not os.path.exists(folder):",
			"        raise FileNotFoundError(f'The folder {folder} does not exist.')",
			"    ",
			"    temp_folder = os.path.join(folder, 'temp')",
			"    ",
			"    if os.path.exists(temp_folder):",
			"        logging.info(f'Temporary folder {temp_folder} already exists.')",
			"        ",
			"        if os.path.exists(os.path.join(temp_folder, '.temp')):",
			"            logging.info(f'Removing temporary folder {temp_folder}.')",
			"            shutil.rmtree(temp_folder)",
			"        else:",
			"            raise FileExistsError(f'The temporary folder {temp_folder} already exists.')",
			"    ",
			"    logging.info(f'Creating temporary folder {temp_folder}.')",
			"    os.mkdir(temp_folder)",
			"    open(os.path.join(temp_folder, '.temp'), 'w').close()",
			"    ",
			"    return None"
		]
	},
	"python main and run":{
		"scope": "python",
		"prefix": "def main",
		"body": [
			"def main():",
			"    pass",
			"",
			"if __name__ == '__main__':",
			"    try:",
			"        main()",
			"    except Exception as e:",
			"        logging.exception(e)",
			"        raise e from e"
		]
	},
	"Decorator template": {
		"scope": "python",
		"prefix": "def decorator",
		"body": [
			"import functools",
					"",
			"def decorator(func):",
			"    @functools.wraps(func)",
			"    def wrapper_decorator(*args, **kwargs):",
			"        # Do something before",
			"        value = func(*args, **kwargs)",
			"        # Do something after",
			"        return value",
			"    return wrapper_decorator"
		]
	},
	"Mqtt Client Class":{
		"scope": "python",
		"description": "Create a class for an MQTT client",
		"prefix": "mqtt",
		"body": [
			"class BaseClient:",
			"    '''Base class for mqtt clients.'''",
			"    ",
			"    def __init__(self, ip_addr: str = 'localhost', port: int = 1883) -> None:",
			"        '''",
			"        Create a mqtt client.",
			"        ",
			"        Creates an instance of a mqtt client and connects to the broker.",
			"        ",
			"        Args:",
			"            ip_addr (str): The ip address of the mqtt broker. Default is 'localhost'.",
			"            port (int): The port of the mqtt broker. Default is 1883.",
			"        '''",
			"        self.client = mqtt.Client()",
			"        self.client.on_connect = self.on_connect",
			"        self.client.on_connect_fail = self.on_connect_failed",
			"        self.client.on_disconnect = self.on_disconnect",
			"        self.client.on_message = self.on_message",
			"        self.client.on_log = self.on_log",
			"        self.client.on_publish = self.on_publish",
			"        self.client.on_subscribe = self.on_subscribe",
			"        self.client.on_unsubscribe = self.on_unsubscribe",
			"        self.client.connect(ip_addr, 1883, 60)",
			"        self.client.loop_start()",
			"        ",
			"    ",
			"    def on_connect(self, callback_client, userdata, connect_flags, reason_code) -> None:",
			"        '''",
			"        Handle the callback when the client connects to the broker.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"            connect_flags: Response flags sent by the broker.  ",
			"            reason_code: The connection result.",
			"",
			"        Returns:",
			"            None",
			"        '''",
			"        if reason_code == 0:",
			"            logging.info('Client connected to broker %s', callback_client._host)",
			"            callback_client.connected_flag = True",
			"        else:",
			"            logging.error('Connection failed, return code: %s', reason_code)",
			"            callback_client.bad_connection_flag = True",
			"        return",
			"            ",
			"    def on_connect_failed(self, callback_client, userdata):",
			"        '''",
			"        Handle the callback when the client fails to connect to the broker.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"",
			"        Returns:",
			"            None",
			"        '''",
			"        logging.error('Connection failed')",
			"        callback_client.bad_connection_flag = True",
			"        return",
			"            ",
			"    def on_disconnect(self, callback_client, userdata, rc):",
			"        '''",
			"        Handle the callback when the client disconnects from the broker.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"            rc: The connection result.",
			"",
			"        Returns:",
			"            None",
			"        '''",
			"        logging.info('Disconnected from broker return code: %s', rc)",
			"        callback_client.connected_flag = False",
			"        return",
			"        ",
			"    def on_message(self, callback_client, userdata, message):",
			"        '''",
			"        Handle the callback when the client receives a message from the broker.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"            message: An instance of MQTTMessage.",
			"           ",
			"        Returns:",
			"            None",
			"        '''",
			"        payload = message.payload.decode().rstrip('\\n')",
			"        topic = message.topic",
			"        logging.info('Message on %s: %s', topic, payload)",
			"        return",
			"        ",
			"    def on_log(self, callback_client, userdata, level, buf):",
			"        '''",
			"        Handle the callback when the client logs a message.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"            level: The log level.",
			"            buf: The message buffer.",
			"        ",
			"        Returns:",
			"            None",
			"        '''",
			"        logging.debug('MQTT Client Log : Level: %s, Message: %s', level, buf)",
			"        return",
			"    ",
			"    def on_publish(self, callback_client, userdata, mid):",
			"        '''",
			"        Handle the callback when the client publishes a message to the broker.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"            mid: The message id.",
			"         ",
			"        Returns:",
			"            None",
			"        '''",
			"        logging.debug('Message published: %s', mid)",
			"        return",
			"        ",
			"    def on_subscribe(self, callback_client, userdata, mid, reason_code_list):",
			"        '''",
			"        Handle the callback when the client subscribes to a topic.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"            mid: The message id.",
			"            reason_code_list: The list of reason codes for the topics.",
			"         ",
			"        Returns:",
			"            None",
			"        '''",
			"        logging.debug('Subscribed to topic: %s with reason codes: %s', mid, reason_code_list)",
			"        return",
			"        ",
			"    def on_unsubscribe(self, callback_client, userdata, mid):",
			"        '''",
			"        Handle the callback when the client unsubscribes from a topic.",
			"        ",
			"        Args:",
			"            client: The client instance for this callback.",
			"            userdata: The private user data as set in Client() or userdata_set().",
			"            mid: The message id.",
			"        ",
			"        Returns:",
			"            None",
			"        '''",
			"        logging.debug('Unsubscribed from topic: %s', mid)",
			"        return",
			"   "
		]
	}
}
